name: Auto Release

# Runs when PR is merged to main
# Bumps version, updates changelog, creates tag and GitHub release
#
# SETUP REQUIRED:
# This workflow needs a PAT to bypass branch protection rules.
# 1. Create a Fine-grained PAT at https://github.com/settings/tokens?type=beta
#    - Repository access: This repository only
#    - Permissions: Contents (Read and write), Pull requests (Read and write)
# 2. Add as repository secret named RELEASE_TOKEN:
#    Settings â†’ Secrets and variables â†’ Actions â†’ New repository secret

on:
  pull_request:
    branches: [main]
    types: [closed]

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    # Only run when PR is merged (not just closed)
    if: github.event.pull_request.merged == true
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get previous release tag
        id: prev_tag
        run: |
          # Get the latest tag (previous release)
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$PREV_TAG" ]; then
            # No tags yet, use first commit
            PREV_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "Previous release: $PREV_TAG"

      - name: Check for release-worthy commits
        id: check
        env:
          PR_LABELS: ${{ toJson(github.event.pull_request.labels.*.name) }}
        run: |
          # Get commits since last release on main
          COMMITS=$(git log --pretty=format:"%s" --no-merges ${{ steps.prev_tag.outputs.tag }}..HEAD)

          # Filter to commits from this PR number
          PR_NUMBER="${{ github.event.pull_request.number }}"

          if [ -z "$COMMITS" ]; then
            echo "No new commits since last release"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Commits since last release:"
          echo "$COMMITS"

          # Check for release-worthy commits (feat, fix, docs, refactor, perf)
          if ! echo "$COMMITS" | grep -qE "^(feat|fix|docs|refactor|perf)(\(.+\))?:"; then
            echo "No release-worthy commits (only chore/ci/test/build)"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "should_release=true" >> $GITHUB_OUTPUT

          # Check PR labels for manual version control
          # Labels: release:major, release:minor (default: patch)
          if echo "$PR_LABELS" | grep -q "release:major"; then
            echo "Label 'release:major' found - major bump"
            echo "bump_type=major" >> $GITHUB_OUTPUT
            exit 0
          fi

          if echo "$PR_LABELS" | grep -q "release:minor"; then
            echo "Label 'release:minor' found - minor bump"
            echo "bump_type=minor" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Default to patch for all release-worthy commits
          echo "No version label - defaulting to patch bump"
          echo "bump_type=patch" >> $GITHUB_OUTPUT

      - name: Get current version
        if: steps.check.outputs.should_release == 'true'
        id: current
        run: |
          CURRENT=$(jq -r '.version' package.json)
          echo "version=$CURRENT" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT"

      - name: Calculate new version
        if: steps.check.outputs.should_release == 'true'
        id: version
        run: |
          CURRENT="${{ steps.current.outputs.version }}"
          BUMP="${{ steps.check.outputs.bump_type }}"

          if [[ "$CURRENT" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
          else
            echo "Could not parse version: $CURRENT"
            exit 1
          fi

          case $BUMP in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Calculated: $CURRENT -> $NEW_VERSION ($BUMP)"

      - name: Update package.json
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"
          jq --arg v "$NEW_VERSION" '.version = $v' package.json > package.json.tmp
          mv package.json.tmp package.json
          echo "Updated package.json to $NEW_VERSION"

      - name: Generate changelog entries
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"
          TODAY=$(date +%Y-%m-%d)
          PR_TITLE="${{ github.event.pull_request.title }}"

          mkdir -p docs

          # Generate DETAILED changelog from commits since last release
          > /tmp/changelog_detailed.md

          # Get commits since last release on main
          COMMITS=$(git log --pretty=format:"%s" --no-merges ${{ steps.prev_tag.outputs.tag }}..HEAD)

          # Added (feat)
          ADDED=$(echo "$COMMITS" | grep -iE "^feat(\(.+\))?:" | sed 's/^[^:]*: /- /' || true)
          if [ -n "$ADDED" ]; then
            echo "### Added" >> /tmp/changelog_detailed.md
            echo "$ADDED" >> /tmp/changelog_detailed.md
            echo "" >> /tmp/changelog_detailed.md
          fi

          # Changed (refactor, perf)
          CHANGED=$(echo "$COMMITS" | grep -iE "^(refactor|perf)(\(.+\))?:" | sed 's/^[^:]*: /- /' || true)
          if [ -n "$CHANGED" ]; then
            echo "### Changed" >> /tmp/changelog_detailed.md
            echo "$CHANGED" >> /tmp/changelog_detailed.md
            echo "" >> /tmp/changelog_detailed.md
          fi

          # Fixed
          FIXED=$(echo "$COMMITS" | grep -iE "^fix(\(.+\))?:" | sed 's/^[^:]*: /- /' || true)
          if [ -n "$FIXED" ]; then
            echo "### Fixed" >> /tmp/changelog_detailed.md
            echo "$FIXED" >> /tmp/changelog_detailed.md
            echo "" >> /tmp/changelog_detailed.md
          fi

          # Docs
          DOCS=$(echo "$COMMITS" | grep -iE "^docs(\(.+\))?:" | sed 's/^[^:]*: /- /' || true)
          if [ -n "$DOCS" ]; then
            echo "### Documentation" >> /tmp/changelog_detailed.md
            echo "$DOCS" >> /tmp/changelog_detailed.md
            echo "" >> /tmp/changelog_detailed.md
          fi

          # Generate SUMMARY changelog (for root CHANGELOG.md)
          # Just the PR title as a one-liner
          > /tmp/changelog_summary.md
          echo "- ${PR_TITLE}" >> /tmp/changelog_summary.md

          echo "=== Detailed changelog ==="
          cat /tmp/changelog_detailed.md
          echo "=== Summary changelog ==="
          cat /tmp/changelog_summary.md

      - name: Update CHANGELOG.md (summary)
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"
          PREV_VERSION="${{ steps.current.outputs.version }}"
          TODAY=$(date +%Y-%m-%d)

          # Check if this version already in changelog
          if grep -q "## \[$NEW_VERSION\]" CHANGELOG.md; then
            echo "Version $NEW_VERSION already in changelog, skipping"
            exit 0
          fi

          # Create the new entry (summary only - just PR title)
          {
            echo "## [$NEW_VERSION] - $TODAY"
            echo ""
            cat /tmp/changelog_summary.md
          } > /tmp/new_section.md

          # Insert new section after line 7
          {
            head -n 7 CHANGELOG.md
            echo ""
            cat /tmp/new_section.md
            tail -n +8 CHANGELOG.md
          } > CHANGELOG.tmp.md

          mv CHANGELOG.tmp.md CHANGELOG.md

          # Add version link
          if ! grep -q "^\[$NEW_VERSION\]:" CHANGELOG.md; then
            echo "[$NEW_VERSION]: https://github.com/${{ github.repository }}/compare/v${PREV_VERSION}...v${NEW_VERSION}" >> CHANGELOG.md
          fi

      - name: Update docs/CHANGELOG-DETAILED.md
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"
          PREV_VERSION="${{ steps.current.outputs.version }}"
          TODAY=$(date +%Y-%m-%d)

          mkdir -p docs

          # Create docs/CHANGELOG-DETAILED.md if it doesn't exist
          if [ ! -f docs/CHANGELOG-DETAILED.md ]; then
            echo "# Detailed Changelog" > docs/CHANGELOG-DETAILED.md
            echo "" >> docs/CHANGELOG-DETAILED.md
            echo "Full changelog with categorized changes from all commits." >> docs/CHANGELOG-DETAILED.md
            echo "" >> docs/CHANGELOG-DETAILED.md
            echo "For a summary, see [CHANGELOG.md](../CHANGELOG.md)." >> docs/CHANGELOG-DETAILED.md
            echo "" >> docs/CHANGELOG-DETAILED.md
          fi

          # Check if this version already in detailed changelog
          if grep -q "## \[$NEW_VERSION\]" docs/CHANGELOG-DETAILED.md; then
            echo "Version $NEW_VERSION already in detailed changelog, skipping"
            exit 0
          fi

          # Create the new detailed entry
          {
            echo "## [$NEW_VERSION] - $TODAY"
            echo ""
            cat /tmp/changelog_detailed.md
          } > /tmp/new_detailed_section.md

          # Insert after header (line 6)
          {
            head -n 6 docs/CHANGELOG-DETAILED.md
            echo ""
            cat /tmp/new_detailed_section.md
            tail -n +7 docs/CHANGELOG-DETAILED.md
          } > docs/CHANGELOG-DETAILED.tmp.md

          mv docs/CHANGELOG-DETAILED.tmp.md docs/CHANGELOG-DETAILED.md

          # Add version link
          if ! grep -q "^\[$NEW_VERSION\]:" docs/CHANGELOG-DETAILED.md; then
            echo "[$NEW_VERSION]: https://github.com/${{ github.repository }}/compare/v${PREV_VERSION}...v${NEW_VERSION}" >> docs/CHANGELOG-DETAILED.md
          fi

      - name: Commit version bump to main
        if: steps.check.outputs.should_release == 'true'
        id: commit
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"

          # Check if there are changes to commit
          if git diff --quiet package.json CHANGELOG.md docs/CHANGELOG-DETAILED.md 2>/dev/null; then
            echo "No changes to commit"
            echo "committed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git add package.json CHANGELOG.md docs/CHANGELOG-DETAILED.md
          git commit -m "chore(release): bump to v${NEW_VERSION} [skip ci]"
          git push origin main
          echo "committed=true" >> $GITHUB_OUTPUT

      - name: Create tag and release
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new }}"

          # Check if tag already exists
          if git rev-parse "v${NEW_VERSION}" >/dev/null 2>&1; then
            echo "Tag v${NEW_VERSION} already exists"
            exit 0
          fi

          # If we committed, we need to tag the commit we just pushed
          # Otherwise tag the current HEAD (merge commit)
          git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
          git push origin "v${NEW_VERSION}"
          echo "âœ“ Created tag v${NEW_VERSION}"

      - name: Create GitHub Release
        if: steps.check.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.new }}
          name: v${{ steps.version.outputs.new }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}

      - name: Add comment to PR
        if: steps.check.outputs.should_release == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.RELEASE_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸŽ‰ **Released v${{ steps.version.outputs.new }}**\n\nVersion bumped and tagged on main branch.\n\n[View Release](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.new }})`
            })
